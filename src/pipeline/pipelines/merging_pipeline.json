{
    "pipeline_name": "PLEXOS Object Merging Pipeline",
    "description": "Merges multiple PLEXOS objects into a single object with consolidated properties and memberships",
    "initial_context": {
        "user_input": "Merge all the regional wind generators in Germany into a single Germany Wind Fleet generator",
        "plexos_model_location": "C:\\Users\\ENTSOE\\Tera-joule\\Terajoule - Terajoule\\Projects\\Sectoral Model\\TJ Sectorial Model\\TJ_2050_Debug_V20_copy.xml",
        "strategy_action": "merge",
        "merge_config": {
            "property_aggregation": {
                "capacity": "sum",
                "efficiency": "weighted_average",
                "min_stable_level": "minimum",
                "default": "first_non_null"
            },
            "membership_handling": "union",
            "delete_source_objects": "True",
            "conflict_resolution": "llm_assisted"
        },
        "plexos_architecture_note": "In PLEXOS, properties are assigned to collections (memberships between objects), not directly to objects. Common collections include System.{Class} for system-level properties and {Class}.{OtherClass} for relationships.",
        "static_context_strings": {
            "default_llm_context": "You are an expert in PLEXOS modeling working with an interlinked model including Electricity, Hydrogen, Methane and Synthetic fuels.",
            "get_class_context": "You are selecting a PLEXOS class based on the user's request. Consider the type of PLEXOS objects being described.",
            "merge_selection_context": "Identify objects to merge based on common characteristics like technology type, region, fuel type, or ownership. Objects should be of the same class.",
            "property_merge_context": "When merging properties from memberships: sum capacities and quantities for System.{Class} properties, use weighted averages for efficiencies, take most restrictive values for constraints. Remember properties belong to collections/memberships, not directly to objects.",
            "conflict_resolution_context": "Resolve property conflicts by considering the physical meaning and the collection context: for System.Generator capacity sum all values, for efficiency use capacity-weighted average, for constraints use most restrictive value."
        }
    },
    
    "tasks": [
        {
            "id": "read_plexos_model",
            "description": "Load the PLEXOS model",
            "function": "load_model",
            "inputs": {
                "model_location": "initial_context.plexos_model_location"
            },
            "outputs": {
                "db_connection": "result"
            },
            "type": "setup_function_call"
        },
        
        {
            "id": "choose_source_class_group",
            "description": "Determine the class group from user input",
            "function": "get_plexos_table_and_llm_pick_item_id",
            "inputs": {
                "user_input": "initial_context.user_input",
                "llm_context": "initial_context.static_context_strings.default_llm_context",
                "item_type_for_get_item_id": "t_class_group",
                "item_id_column": "class_group_id",
                "item_name_column": "name",
                "strategy_action": "initial_context.strategy_action",
                "model": "gpt-4-mini"
            },
            "outputs": {
                "class_group_id": "result.id",
                "class_group_name": "result.name"
            },
            "type": "LLM API Call"
        },
        
        {
            "id": "choose_source_class",
            "description": "Determine the class for objects to merge",
            "function": "get_plexos_table_and_llm_pick_item_id",
            "inputs": {
                "user_input": "initial_context.user_input",
                "llm_context": "initial_context.static_context_strings.get_class_context",
                "item_type_for_get_item_id": "t_class",
                "get_item_id_filters": {"grp": "tasks.choose_source_class_group.outputs.class_group_id"},
                "item_id_column": "class_id",
                "item_name_column": "name",
                "strategy_action": "initial_context.strategy_action",
                "model": "gpt-4-mini"
            },
            "outputs": {
                "class_id": "result.id",
                "class_name": "result.name"
            },
            "type": "LLM API Call"
        },
        
        {
            "id": "read_all_categories_for_source_class",
            "description": "Read all categories for the determined class",
            "type": "plexos_api_call",
            "function": "get_categories",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection",
                "nClassId": "tasks.choose_source_class.outputs.class_id"
            },
            "outputs": {
                "raw_categories_list": "result"
            }
        },
        
        {
            "id": "choose_source_category",
            "description": "LLM selects the category containing objects to merge",
            "function": "choose_item",
            "inputs": {
                "user_input": "initial_context.user_input",
                "item_set": "tasks.read_all_categories_for_source_class.outputs.raw_categories_list",
                "item_type": "Category",
                "llm_context": "initial_context.static_context_strings.merge_selection_context"
            },
            "outputs": {
                "final_category_name": "result.selected_name",
                "category_selection_type": "result.selection_type"
            },
            "type": "LLM API Call"
        },
        {
            "id": "get_candidate_objects",
            "description": "Retrieve all objects matching the merge criteria",
            "function": "get_plexos_objects",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection",
                "nClassId": "tasks.choose_source_class.outputs.class_id",
                "strCategory": "tasks.choose_source_category.outputs.final_category_name"
            },
            "outputs": {
                "all_objects": "result"
            },
            "type": "plexos_api_call"
        },
        
        {
            "id": "select_objects_to_merge",
            "description": "LLM selects specific objects to merge from candidates",
            "function": "choose_object_subset",
            "inputs": {
                "user_input": "initial_context.user_input",
                "object_set": "tasks.get_candidate_objects.outputs.all_objects",
                "object_type": "tasks.choose_source_class.outputs.class_name",
                "operation_type": "merge",
                "selection_mode": "multiple",
                "llm_context": "initial_context.static_context_strings.merge_selection_context",
                "model": "gpt-4"
            },
            "outputs": {
                "objects_to_merge": "result.selected_objects",
                "merge_rationale": "result.reasoning"
            },
            "type": "LLM API Call"
        },
        
        {
            "id": "determine_merged_object_name",
            "description": "Generate name for the merged object",
            "function": "generate_merged_name",
            "inputs": {
                "source_objects": "tasks.select_objects_to_merge.outputs.objects_to_merge",
                "user_input": "initial_context.user_input",
                "naming_hint": "Provide a descriptive name that represents the combined entity"
            },
            "outputs": {
                "merged_object_name": "result.name",
                "merged_object_description": "result.description"
            },
            "type": "LLM API Call"
        },
        
        {
            "id": "create_merged_object",
            "description": "Create the new merged object in PLEXOS",
            "function": "add_object",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection",
                "strName": "tasks.determine_merged_object_name.outputs.merged_object_name",
                "nClassId": "tasks.choose_source_class.outputs.class_id",
                "strCategory": "tasks.choose_source_category.outputs.final_category_name",
                "strDescription": "tasks.determine_merged_object_name.outputs.merged_object_description"
            },
            "outputs": {
                "created": "result"
            },
            "type": "plexos_api_call"
        },
        
        {
            "id": "collect_all_memberships",
            "description": "Gather all memberships from objects to be merged",
            "type": "loop",
            "iterate_on": "tasks.select_objects_to_merge.outputs.objects_to_merge",
            "loop_variable_name": "source_object",
            "tasks": [
                {
                    "id": "get_object_memberships",
                    "description": "Get memberships for current source object",
                    "function": "get_object_collections",
                    "inputs": {
                        "db": "tasks.read_plexos_model.outputs.db_connection",
                        "object_name": "loop.source_object",
                        "class_name": "tasks.choose_source_class.outputs.class_name",
                        "class_id": "tasks.choose_source_class.outputs.class_id"
                    },
                    "outputs": {
                        "memberships": "result"
                    },
                    "type": "plexos_api_call"
                }
            ],
            "outputs": {
                "all_source_memberships": "accumulated_results"
            }
        },
        
        {
            "id": "create_merged_object_memberships",
            "description": "Create necessary memberships for merged object before properties",
            "function": "create_object_memberships",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection",
                "object_name": "tasks.determine_merged_object_name.outputs.merged_object_name",
                "class_id": "tasks.choose_source_class.outputs.class_id",
                "source_memberships": "tasks.collect_all_memberships.outputs.all_source_memberships"
            },
            "outputs": {
                "created_memberships": "result"
            },
            "type": "function_call"
        },
        
        {
            "id": "collect_all_properties",
            "description": "Gather all properties from objects to be merged via their memberships",
            "type": "loop",
            "iterate_on": "tasks.select_objects_to_merge.outputs.objects_to_merge",
            "loop_variable_name": "source_object",
            "tasks": [
                {
                    "id": "get_object_properties",
                    "description": "Get properties for current source object from all its memberships",
                    "function": "get_all_object_properties_with_collections",
                    "inputs": {
                        "db": "tasks.read_plexos_model.outputs.db_connection",
                        "object_name": "loop.source_object",
                        "class_id": "tasks.choose_source_class.outputs.class_id"
                    },
                    "outputs": {
                        "properties": "result"
                    },
                    "type": "plexos_api_call"
                }
            ],
            "outputs": {
                "all_source_properties": "accumulated_results"
            }
        },
        
        {
            "id": "aggregate_properties",
            "description": "Aggregate properties from all source objects by collection",
            "function": "aggregate_object_properties_by_collection",
            "inputs": {
                "all_properties": "tasks.collect_all_properties.outputs.all_source_properties",
                "aggregation_rules": "initial_context.merge_config.property_aggregation",
                "source_objects": "tasks.select_objects_to_merge.outputs.objects_to_merge",
                "merged_object_name": "tasks.determine_merged_object_name.outputs.merged_object_name",
                "created_memberships": "tasks.create_merged_object_memberships.outputs.created_memberships",
                "llm_context": "initial_context.static_context_strings.property_merge_context",
                "conflict_resolution": "initial_context.merge_config.conflict_resolution"
            },
            "outputs": {
                "aggregated_properties": "result.properties",
                "aggregation_report": "result.report"
            },
            "type": "function_call"
        },
        
        {
            "id": "create_merged_properties",
            "description": "Create aggregated properties on merged object memberships",
            "type": "loop",
            "iterate_on": "tasks.aggregate_properties.outputs.aggregated_properties",
            "loop_variable_name": "merged_property",
            "tasks": [
                {
                    "id": "add_property_to_membership",
                    "description": "Add property to appropriate membership",
                    "function": "add_property_to_membership",
                    "inputs": {
                        "db": "tasks.read_plexos_model.outputs.db_connection",
                        "collection_id": "loop.merged_property.collection_id",
                        "parent_object": "loop.merged_property.parent_object",
                        "child_object": "loop.merged_property.child_object",
                        "property_id": "loop.merged_property.property_id",
                        "property_value": "loop.merged_property.value",
                        "property_unit": "loop.merged_property.unit",
                        "date_from": "loop.merged_property.date_from",
                        "date_to": "loop.merged_property.date_to",
                        "scenario": "loop.merged_property.scenario",
                        "pattern": "loop.merged_property.pattern",
                        "band": "loop.merged_property.band"
                    },
                    "outputs": {
                        "created": "result"
                    },
                    "type": "plexos_api_call"
                }
            ]
        },
        
        {
            "id": "handle_constraint_references",
            "description": "Update any constraints referencing the merged objects",
            "function": "update_constraint_references",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection",
                "old_objects": "tasks.select_objects_to_merge.outputs.objects_to_merge",
                "new_object": "tasks.determine_merged_object_name.outputs.merged_object_name",
                "class_id": "tasks.choose_source_class.outputs.class_id"
            },
            "outputs": {
                "updated_constraints": "result"
            },
            "type": "function_call"
        },
        
        {
            "id": "delete_source_objects",
            "description": "Delete original objects if configured",
            "condition": "initial_context.merge_config.delete_source_objects == true",
            "type": "loop",
            "iterate_on": "tasks.select_objects_to_merge.outputs.objects_to_merge",
            "loop_variable_name": "object_to_delete",
            "tasks": [
                {
                    "id": "delete_object",
                    "description": "Delete source object",
                    "function": "delete_object",
                    "inputs": {
                        "db": "tasks.read_plexos_model.outputs.db_connection",
                        "object_name": "loop.object_to_delete",
                        "class_id": "tasks.choose_source_class.outputs.class_id"
                    },
                    "outputs": {
                        "deleted": "result"
                    },
                    "type": "plexos_api_call"
                }
            ]
        },
        
        {
            "id": "generate_merge_report",
            "description": "Generate summary of merge operation",
            "function": "generate_operation_report",
            "inputs": {
                "operation_type": "merge",
                "source_objects": "tasks.select_objects_to_merge.outputs.objects_to_merge",
                "merged_object": "tasks.determine_merged_object_name.outputs.merged_object_name",
                "property_aggregation": "tasks.aggregate_properties.outputs.aggregation_report",
                "membership_count": "tasks.create_merged_object_memberships.outputs.created_memberships"
            },
            "outputs": {
                "report": "result"
            },
            "type": "function_call"
        },
        
        {
            "id": "close_plexos_database",
            "description": "Close the PLEXOS database connection",
            "function": "close_model",
            "inputs": {
                "db": "tasks.read_plexos_model.outputs.db_connection"
            },
            "outputs": {
                "close_status": "result"
            },
            "type": "plexos_api_call"
        }
    ]
}